import sys
from random import randint

f = open(sys.argv[1], 'r')
att = (f.readline()).split()
k_global = int(att[0])
t_global = int(att[1])
dna_list_global = [line.strip() for line in f.readlines()]

# This function returns the hamming distance between two strings.
def get_hamming(string1, string2):
    s1 = list(string1)
    s2 = list(string2)
    mismatches = 0
    for i in range(len(s1)):
        if s1[i] != s2[i]:
            mismatches += 1
    return mismatches


# This function returns the score of the motifs list. Iterates
# over the length of the motif and concats the chars of the same
# index for each motif. Then compares each motif to a string of
# each 'ACGT' chars of the same length and gets the hamming
# distance. Stores the score to a list and adds the min to the
# total score.
def get_score(motifs):
    score = 0
    for i in range(len(motifs[0])):
        concat_motif = ''                     # recombined motif variable
        for j in range(len(motifs)):          # concat char at index i from each motif
            concat_motif += motifs[j][i]
            
        temp_score_holder = []                # score list per iteration
        for base in 'ACGT':
            comparer = base*len(concat_motif) # generate comparer(ex. AAAAAAA)
            temp_score = get_hamming(concat_motif, comparer)
            temp_score_holder.append(temp_score)
        score += min(temp_score_holder)       # add min score
        
    return score


# This function returns the profile generated by the input motif
# based on the equation given in class. Iterates over the length
# of a motif and concats the chars of the same index for each
# motif. Then generates a probability from the equation using the
# number of occurences of each base + 1 and dividing it by t + 4.
# Then add each probability to list and append list to profile.
def get_pseudocount_profile(motifs):
    profile = []
    for i in range(len(motifs[0])): 
        concat_motif = ''               # recombined motif variable
        for j in range(len(motifs)):    # concat char at index i from each motif
            concat_motif += motifs[j][i]

        prob_list = []
        for base in 'ACGT':
            probability = float(concat_motif.count(base)+1)/float(len(concat_motif)+4)
            prob_list.append(probability)
        profile.append(prob_list)

    return profile


# This function returns the most profile probable motif in input.
# Iterates over a dna sequence and multiples the total probability
# with the respective loction in the profile. Does this for each
# k-mer in the sequence.
def get_most_probable(dna, k, profile):
    curr_prob = 1.0
    best_prob = 0.0
    motif = ''
    
    for i in range((len(dna)-k+1)):
        curr_prob = 1.0
        word = list(dna[i:i+k])

        for i in range(len(word)):
            if word[i] == 'A':
                curr_prob *= float(profile[i][0])
            elif word[i] == 'C':
                curr_prob *= float(profile[i][1])
            elif word[i] == 'G':
                curr_prob *= float(profile[i][2])
            elif word[i] == 'T':
                curr_prob *= float(profile[i][3])
        if curr_prob > best_prob:
            best_prob = curr_prob
            motif = "".join(str(p) for p in word)
            
    return motif


# This function returns the best motif based on the pseudocode
# provided by the problem. Generate random numbers to get the
# index of the motif and use it to get a profile, get the best
# motif, and get a score. Returns a tuple with best motif list
# and score.
def randomized_motif_search(dna_list, k , t):
    rand_nums = []
    motifs = []
    
    # generate random numbers and use them to generate random motifs
    for i in range(t):
        rand_nums.append(randint(0, len(dna_list[0])-k)) # randint nums
    for i in range(len(rand_nums)):                     
        n = rand_nums[i]                                 # assign motifs based
        motifs.append(dna_list[i][n:n+k])                # on rand number
       
    # initialize best with initial score and motif list
    best = [get_score(motifs), motifs]

    # run loop until score is not lowest
    while True:
        profile = get_pseudocount_profile(motifs)
        motifs = [get_most_probable(dna, k, profile) for dna in dna_list]
        curr_score = get_score(motifs)
        if curr_score < best[0]:
            best = [curr_score, motifs]
        else:
            return best
        

# This block runs the code 1000 times and keeps track of the best
# score and motif and then prints in the correct format
best_motifs = [k_global*t_global,[]]
for i in range(1000):
    curr_motifs = randomized_motif_search(dna_list_global, k_global, t_global)
    if curr_motifs[0] < best_motifs[0]:
        best_motifs = curr_motifs
for motif in best_motifs[1]:
    print motif
      

